# -*- coding: utf-8 -*-
"""Project_Simulation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1loUSLSW27ErXvImWssh5o7Uv4j7UtyQX
"""

# Commented out IPython magic to ensure Python compatibility.
import math
import numpy as np
from numpy import random
import scipy.stats as si
from sympy.stats import Normal, cdf
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
# %matplotlib inline
import warnings

N = 350 #Number of grid points.
x_m = 300 #Stock price max
x = np.linspace(0, x_m , N+1) #Space dicretization

sigma = 0.7 #Volatilty
r = 0.1 #Interest rate

#Definition of the coefficients
b = r - sigma**2
beta = sigma**2
c = 2 * r  + beta - sigma**2

#Initialization and declaration of the variables and the lists
xs = x[0]
x_m = x[N]
lambd = []
lambd1 = []
L1 = []
A = []
A1 = []
B = []
B1 = []
C = []
C1 = []
for i in range(len(x)-1):
    L1.append(( x[i+1] + x[i] ) / 2 ) #Computation of the mid-points
T1 = np.array(L1)
T1 = np.insert(T1,0,0) #Insert x[0] in the list
T1 = np.insert(T1, N+1, x_m) #Insert x_m in the list
l = (T1[len(T1)-1] -T1[0]) / (len(T1)-1) #Computaion of the step

#Computation of the lambda
for i in range(len(x)-1):
    lambd.append(  ( sigma**2 * ( T1[i+1]**3 - T1[i]**3 )*( T1[i+2]**3 - T1[i+1]**3 ) ) /  ( 3 * l**2  * ( T1[i+1]**3 - T1[i]**3) + ( T1[i+2]**3 - T1[i+1]**3 ) )) 
lambd1 = np.array(lambd)

#Computation of the elements on the principal diagonal.
for i in range(len(x)-2):
    A.append( - lambd1[i+1] + T1[i+1] * max(b,0) - lambd1[i] - T1[i] * min(b,0) - l * c )
A1 = np.array(A)

#Computation of the elements on the superior diagonal.
for i in range(1,len(x)-2):
    B.append(  lambd1[i]   +  T1[i]  * min(b,0) )
B1 = np.array(B)

#Computation of the elements on the inferior diagonal.
for i in range(1,len(x)-2):
    C.append( lambd1[i]   -  T1[i]  * max(b,0) )
C1 = np.array(C)

"""### Tridiagonal matrix"""

# computation of the tridiagonal matrix
D1 = np.diag(A1) + np.diag(B1 , 1) + np.diag(C1 , -1) 
D = (1/l) * D1

"""### Matrix H"""

G = np.zeros(N-1); G #Define G like an line matrix

G = G.reshape( N-1, 1 ); G #Define G like column matrix

#VN = x_m 
K = 100 #Srike price
def H(tau):

    #Compuations of all the elements of H
    for i in range(N-1):
        if i != N-2:
            G[i] = 0
        else:
            G[i] = (1/l) * (  lambd[N-1] + T1[N+1] * min(b,0) ) * ( x_m  * si.norm.cdf(( np.log(x_m/K) + ( r + 1/2 * sigma**2 ) * tau ) / ( sigma * np.sqrt(tau)) , 0.0 , 1.0) - K * np.exp(-r * tau) * si.norm.cdf(( np.log(x_m/K) + ( r - 1/2 * sigma**2 ) * tau ) / ( sigma * np.sqrt(tau) ) , 0.0 , 1.0) )
    return G

"""### Euler method"""

##This code Compute the initial option value which noted by###
T = 1 #Time to maturty
theta = 0.5 #Theta value
V = []
V0 = np.zeros(N-1)
V0 = V0.reshape(N-1,1)
I = np.identity(N-1)
for i in range(1,N):
    V0[i-1] = max(x[i]-K,0)
#print(V0)
#V0.shape

M = 100 #Number of points along the time axis
dtau = T / (M-1) #step time
inv = np.matrix(np.linalg.inv(I - theta * dtau * D)) #Computation of the inverse matrix
V = [V0] #I nitialization of the V(option value)

#Computation of the option value at each point.
for m in range(M-1):
    t =  np.matrix((I + dtau * (1-theta) * D) )* V0 + theta * dtau * np.matrix(H((m+1)*dtau)) + dtau * (1-theta) * np.matrix(H(m*dtau)) 
    t = inv * t
    #print(t.shape)
    V.append(np.array(t))
    V0 = t
V = np.array(V) 
tau1 = np.linspace(0 , T, M) #Time discretization
x1 = np.linspace(l, x[N]-l,N-1) #Space discretization
#print(V)
Q=V[:,:,0] #Slice V
Q.shape
Q1 = Q[-1,:] #Option value at time T(Time to maturity)
#print(Q1)

"""### Plot of the discrete solution"""

X1 , TAU1 = np.meshgrid(x1 , tau1) #Contruction of the grid

#Plot of the discrete solution
plt.figure(figsize=(10,6))
ax = plt.axes(projection='3d')
ax.plot_surface(TAU1,X1,Q, rstride=1, cstride=1,
                cmap='viridis', edgecolor='none')
ax.set_xlabel('time')
ax.set_ylabel('stock price')
ax.set_zlabel('option value');
plt.savefig('discrete.png')

"""### Plot of the Analytical solution of the Black-Sholes equation along the axis $x1$ and $tau1$"""

tau1 = np.linspace(0 , T, M) #Time discretization
x1 = np.linspace(l, x[N]-l,N-1) #Space discretization

#Computation of the analytical solution
def f(x1,tau1):
  d_1 = ( np.log(x1/K) + ( r + 1/2 * sigma**2 ) * tau1 ) / ( sigma * np.sqrt(tau1))  
  d_2 =  ( np.log(x1/K) + ( r - 1/2 * sigma**2 ) * tau1 ) / ( sigma * np.sqrt(tau1) )  
  N_1 =  si.norm.cdf(d_1, 0.0 , 1.0)
  N_2 = si.norm.cdf(d_2, 0.0 , 1.0)
  return(x1 * N_1 - K * np.exp(-r * tau1) * N_2)
X, TAU = np.meshgrid(x1 , tau1) #Contrauction of the grid
Ca_1 = f(X, TAU) #Valuue of the anatycal solution at each point
Caa = Ca_1[-1,:] #Value of the option value at time T
print(Caa)

#Plot of the analytical solution with respect to "X" and "TAU"
plt.figure(figsize=(10,6))
ax = plt.axes(projection='3d')
ax.plot_surface(TAU,X,Ca_1, rstride=1, cstride=1,
                cmap='viridis', edgecolor='none')
ax.set_xlabel('time')
ax.set_ylabel('stock price')
ax.set_zlabel('option value');
plt.savefig('analytical.png')

"""###Here we are not looking of this solution. I just computed to see the behavior of the analytical solution along $x$ and $tau$

### Plot of the Anatycal solution of the Black-Scholes equation along the axis $x$ and $tau$
"""

tau = np.linspace(0, T , M)
x = np.linspace(0, x_m , N+1)
#print(tau)
def f(x,tau):
  d1 = ( np.log(x/K) + ( r + 1/2 * sigma**2 ) * tau ) / ( sigma * np.sqrt(tau))  
  d2 =  ( np.log(x/K) + ( r - 1/2 * sigma**2 ) * tau ) / ( sigma * np.sqrt(tau) )  
  N1 =  si.norm.cdf(d1, 0.0 , 1.0)
  N2 = si.norm.cdf(d2, 0.0 , 1.0)
  return(x * N1 - K * np.exp(-r * tau) * N2)
X, TAU = np.meshgrid(x, tau)
Ca = f(X, TAU)
#print(x * N1 - K * np.exp(-r * tau) * N2)
#Ca[0,2]=0
#print(Ca)
#Ca.shape
#len(X[0])

plt.figure(figsize=(10,6))
ax = plt.axes(projection='3d')
ax.plot_surface(TAU,X,Ca, rstride=1, cstride=1,
                cmap='viridis', edgecolor='none')
ax.set_xlabel('time')
ax.set_ylabel('stock price')
ax.set_zlabel('option value');

"""### Error Analysis"""

##This code compute the L^2-error at time T"

#Initializtion of the sum
s1 = 0
s2 = 0
#Computation of the L^2-error formular
for i in range(N-1):
  s1 = s1 + ( abs(Caa[i]-Q1[i]) )**2 #Computation of the numerator without the square
  s2 = s2 + ( abs(Caa[i]) )**2 #Computation of the denominator withoutthe square
r1 = np.sqrt(s1) #Computation of the numerator with the square
r2 = np.sqrt(s2) #Computation of the denominator with the square
Err = r1 / r2 #error value
print(Err)

"""###  rate of convergence of the TPFA"""

#Computation of the rate of convergence using polyfit
#The idea is to see the equation of the line which pass through all points which can describe a line.
x = np.array([np.log(x_m/50), np.log(x_m/100),np.log(x_m/150),np.log(x_m/200),np.log(x_m/250),np.log(x_m/300),np.log(x_m/350)])
y = np.array([np.log(0.15990361532342243), np.log(0.13738831721189304),np.log(0.11558600582767335),np.log(0.09011863193895389),np.log(0.061529826335805934),np.log(0.0328905797134449),np.log(0.02373368993757551)])
z = np.polyfit(x,y,1) #determination of the equation which is given by y = ax+b
print(z) #Give us the value of 'a' and 'b' in the equation y = ax+b

"""### Plot of the convergence"""

#PLot of the line using loglog scale
plt.figure(figsize=(10,6))
x = [x_m/200,x_m/250,x_m/300,x_m/350]
y = [0.09011863193895389,0.061529826335805934,0.0328905797134449,0.02373368993757551]
plt.loglog(x, y)
plt.xlabel('step', fontsize = 18)
plt.ylabel('error', fontsize =18);
plt.savefig('convergence')

